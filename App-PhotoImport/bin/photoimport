#!/usr/bin/perl -w

use strict;
use warnings;
use Cwd;
use File::Find;
use File::Basename;
use Image::ExifTool;
use File::Path qw(make_path);

# Flags
my $verbose = 1;

# Set up hash of valid filetypes
my %filetypes = (
	'jpg' => 'image',
	'mov' => 'video',
);

# Define dirs to move files
my %paths = (
	'image' => '/home/jonathan/Pictures/Photos',
	'video' => '/home/jonathan/Videos/Clips',
);

# Open current dir
my $cwd = cwd();

# Find files in dir
my @files;
find(\&test_filetype, $cwd);

# Collect files with supported filetypes
sub test_filetype {
	my $file = $File::Find::name;
	foreach my $filetype (keys %filetypes) {
		if ($file =~ m/\.$filetype$/i) {
			push @files, $file;
		}
	}
}

# Loop through files
foreach my $file (@files) {
	# Skip if not readable
	next if (!-r $file);

	# Find and parse EXIF date
	my ($YYYY, $MM, $DD, $hh, $mm, $ss) = &parseDate($file) or &skip("Couldn't parse date from EXIF data for $file");

	# Get file extension, always lower case
	my($filename, $dirs) = fileparse($file) or &skip("Couldn't parse filename $file");
	my $suffix = &getSuffix($filename) or &skip("Couldn't parse file extension from $filename");

	# Skip if unknown file type
	&skip("Unrecognised file type $suffix") if (!$filetypes{$suffix});

	# Build destination path
	my $destpath = "$paths{$filetypes{$suffix}}/$YYYY/$YYYY-$MM-$DD";
	my $destfile = "$destpath/$filename";

	# Make sure destination exists and is writable
	if (!-d $destpath) {
		make_path $destpath or &skip("Cannot create $destpath");
	}
	&skip("Destination path $destpath not writable") if (!-w $destpath);

	# Make sure destination file doesn't already exist
	&skip("Destination file $destfile already exists, not overwriting") if (-e $destfile);

	# Move the file
	print "$file  =>  $destfile\n";

}

# SUBS
sub parseDate {
	my $file = shift;
	my $exifTool = new Image::ExifTool or &skip("Couldn't read EXIF data from $file");
	my $exifdata = $exifTool->ImageInfo($file) or &skip("Couldn't read EXIF data from $file");
	if ($$exifdata{'CreateDate'} && $$exifdata{'CreateDate'} =~ m/^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/) {
		return ($1, $2, $3, $4, $5, $6);
	} else {
		return;
	}
}

sub getSuffix {
	my $filename = shift;
	$filename =~ m/\.(\w{1,3})/ or next;
	my $suffix = lc($1);
	return $suffix;
}

sub skip {
	my $msg = shift;
	print "$msg\n" if $verbose;
	next;
}
